package com.ai.reviewer.backend.domain.orchestrator.analyzer;

import com.ai.reviewer.backend.domain.config.AiReviewConfig;
import com.ai.reviewer.shared.enums.Dimension;
import com.ai.reviewer.shared.enums.Severity;
import com.ai.reviewer.shared.model.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * Mock implementation of StaticAnalyzer for testing and development.
 * 
 * <p>This mock analyzer returns predefined findings to demonstrate
 * the analysis workflow without requiring actual static analysis tools.
 */
@Component
public class MockStaticAnalyzer implements StaticAnalyzer {
    
    private static final Logger logger = LoggerFactory.getLogger(MockStaticAnalyzer.class);
    
    @Override
    public String getAnalyzerId() {
        return "mock-static-analyzer";
    }
    
    @Override
    public String getAnalyzerName() {
        return "Mock Static Analyzer";
    }
    
    @Override
    public String getVersion() {
        return "1.0.0-mock";
    }
    
    @Override
    public boolean supportsFile(String fileName) {
        // Support common file types for testing
        return fileName.endsWith(".java") || 
               fileName.endsWith(".js") || 
               fileName.endsWith(".ts") || 
               fileName.endsWith(".py") || 
               fileName.endsWith(".go");
    }
    
    @Override
    public boolean isEnabled() {
        return true;
    }
    
    @Override
    public List<Finding> analyze(RepoRef repository, PullRef pullRequest, 
                               List<DiffHunk> diffHunks, AiReviewConfig config) {
        logger.info("Mock static analyzer analyzing {} diff hunks for PR {}/{}#{}", 
            diffHunks.size(), repository.owner(), repository.name(), pullRequest.number());
        
        List<Finding> findings = new ArrayList<>();
        
        if (diffHunks.isEmpty()) {
            return findings;
        }
        
        // Generate mock findings based on the first diff hunk
        DiffHunk firstHunk = diffHunks.get(0);
        
        // Mock security finding
        findings.add(new Finding(
            "MOCK-SEC-001",
            firstHunk.file(),
            5, 8,
            Severity.MAJOR,
            Dimension.SECURITY,
            "Potential SQL injection vulnerability detected",
            "String concatenation used in SQL query construction",
            "Use parameterized queries or prepared statements to prevent SQL injection attacks",
            null,
            List.of("mock-static-analyzer"),
            0.85
        ));
        
        // Mock quality finding (only if there are multiple hunks)
        if (diffHunks.size() > 1 || firstHunk.patch().split("\n").length > 10) {
            findings.add(new Finding(
                "MOCK-QUA-001",
                firstHunk.file(),
                12, 15,
                Severity.MINOR,
                Dimension.QUALITY,
                "High cyclomatic complexity detected",
                "Method complexity exceeds recommended threshold of 10",
                "Consider breaking this method into smaller, more focused methods",
                null,
                List.of("mock-static-analyzer"),
                0.72
            ));
        }
        
        // Filter findings based on confidence threshold from config
        double confidenceThreshold = config.scoring().ignoreConfidenceBelow();
        List<Finding> filteredFindings = findings.stream()
            .filter(finding -> finding.confidence() >= confidenceThreshold)
            .toList();
        
        logger.info("Mock static analyzer found {} findings (filtered from {} based on confidence threshold {})", 
            filteredFindings.size(), findings.size(), confidenceThreshold);
        
        return filteredFindings;
    }
    
    @Override
    public CompletableFuture<List<Finding>> analyzeAsync(CodeSegment segment, AnalysisContext context) {
        return CompletableFuture.supplyAsync(() -> {
            List<Finding> findings = new ArrayList<>();
            
            // Generate a mock finding for the code segment
            findings.add(new Finding(
                "MOCK-ASYNC-001",
                segment.filePath(),
                segment.startLine(),
                segment.endLine(),
                Severity.MINOR,
                Dimension.MAINTAINABILITY,
                "Mock async analysis finding",
                "This is a mock finding generated by async analysis",
                "Consider improving code structure",
                null,
                List.of("mock-static-analyzer"),
                0.65
            ));
            
            return findings;
        });
    }
    
    @Override
    public AnalyzerValidationResult validateConfiguration(AnalyzerConfig config) {
        // Mock analyzer doesn't require any specific configuration
        return AnalyzerValidationResult.success();
    }
    
    @Override
    public AnalyzerStats getStats() {
        return new AnalyzerStats(
            10, // totalCalls
            9,  // successfulCalls  
            1,  // failedCalls
            150.0, // avgProcessingTimeMs
            java.time.Instant.now().minusSeconds(60), // lastRunTime
            null // lastError
        );
    }
}
